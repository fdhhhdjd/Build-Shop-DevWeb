"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promptForMinInstances = exports.promptForFunctionDeletion = exports.promptForFailurePolicies = void 0;
const clc = require("cli-color");
const functionsDeployHelper_1 = require("./functionsDeployHelper");
const error_1 = require("../../error");
const prompt_1 = require("../../prompt");
const logger_1 = require("../../logger");
const backend = require("./backend");
const pricing = require("./pricing");
const utils = require("../../utils");
function compareFunctions(left, right) {
    if (left.platform != right.platform) {
        return right.platform < left.platform ? -1 : 1;
    }
    if (left.region < right.region) {
        return -1;
    }
    if (left.region > right.region) {
        return 1;
    }
    if (left.id < right.id) {
        return -1;
    }
    if (left.id > right.id) {
        return 1;
    }
    return 0;
}
async function promptForFailurePolicies(options, want, have) {
    const retryFunctions = want.filter((fn) => {
        return backend.isEventTrigger(fn.trigger) && fn.trigger.retry;
    });
    if (retryFunctions.length === 0) {
        return;
    }
    const existingRetryFunctions = have.filter((fn) => {
        return backend.isEventTrigger(fn.trigger) && fn.trigger.retry;
    });
    const newRetryFunctions = retryFunctions.filter((fn) => {
        return !existingRetryFunctions.some(backend.sameFunctionName(fn));
    });
    if (newRetryFunctions.length == 0) {
        return;
    }
    const warnMessage = "The following functions will newly be retried in case of failure: " +
        clc.bold(newRetryFunctions.sort(compareFunctions).map(functionsDeployHelper_1.getFunctionLabel).join(", ")) +
        ". " +
        "Retried executions are billed as any other execution, and functions are retried repeatedly until they either successfully execute or the maximum retry period has elapsed, which can be up to 7 days. " +
        "For safety, you might want to ensure that your functions are idempotent; see https://firebase.google.com/docs/functions/retries to learn more.";
    utils.logLabeledWarning("functions", warnMessage);
    if (options.force) {
        return;
    }
    if (options.nonInteractive) {
        throw new error_1.FirebaseError("Pass the --force option to deploy functions with a failure policy", {
            exit: 1,
        });
    }
    const proceed = await prompt_1.promptOnce({
        type: "confirm",
        name: "confirm",
        default: false,
        message: "Would you like to proceed with deployment?",
    });
    if (!proceed) {
        throw new error_1.FirebaseError("Deployment canceled.", { exit: 1 });
    }
}
exports.promptForFailurePolicies = promptForFailurePolicies;
async function promptForFunctionDeletion(functionsToDelete, force, nonInteractive) {
    let shouldDeleteFns = true;
    if (functionsToDelete.length === 0 || force) {
        return true;
    }
    const deleteList = functionsToDelete
        .sort(compareFunctions)
        .map((fn) => "\t" + functionsDeployHelper_1.getFunctionLabel(fn))
        .join("\n");
    if (nonInteractive) {
        const deleteCommands = functionsToDelete
            .map((func) => {
            return "\tfirebase functions:delete " + func.id + " --region " + func.region;
        })
            .join("\n");
        throw new error_1.FirebaseError("The following functions are found in your project but do not exist in your local source code:\n" +
            deleteList +
            "\n\nAborting because deletion cannot proceed in non-interactive mode. To fix, manually delete the functions by running:\n" +
            clc.bold(deleteCommands));
    }
    else {
        logger_1.logger.info("\nThe following functions are found in your project but do not exist in your local source code:\n" +
            deleteList +
            "\n\nIf you are renaming a function or changing its region, it is recommended that you create the new " +
            "function first before deleting the old one to prevent event loss. For more info, visit " +
            clc.underline("https://firebase.google.com/docs/functions/manage-functions#modify" + "\n"));
        shouldDeleteFns = await prompt_1.promptOnce({
            type: "confirm",
            name: "confirm",
            default: false,
            message: "Would you like to proceed with deletion? Selecting no will continue the rest of the deployments.",
        });
    }
    return shouldDeleteFns;
}
exports.promptForFunctionDeletion = promptForFunctionDeletion;
async function promptForMinInstances(options, want, have) {
    if (options.force) {
        return;
    }
    const increasesCost = want.some((wantFn) => {
        if (!pricing.canCalculateMinInstanceCost(wantFn)) {
            return true;
        }
        const wantCost = pricing.monthlyMinInstanceCost([wantFn]);
        const haveFn = have.find(backend.sameFunctionName(wantFn));
        let haveCost;
        if (!haveFn) {
            haveCost = 0;
        }
        else if (!pricing.canCalculateMinInstanceCost(wantFn)) {
            return true;
        }
        else {
            haveCost = pricing.monthlyMinInstanceCost([haveFn]);
        }
        return wantCost > haveCost;
    });
    if (!increasesCost) {
        return;
    }
    if (options.nonInteractive) {
        throw new error_1.FirebaseError("Pass the --force option to deploy functions that increase the minimum bill", {
            exit: 1,
        });
    }
    const functionLines = want
        .filter((fn) => fn.minInstances)
        .sort(compareFunctions)
        .map((fn) => {
        return (`\t${functionsDeployHelper_1.getFunctionLabel(fn)}: ${fn.minInstances} instances, ` +
            backend.memoryOptionDisplayName(fn.availableMemoryMb || 256) +
            " of memory each");
    })
        .join("\n");
    let costLine;
    if (want.some((fn) => !pricing.canCalculateMinInstanceCost(fn))) {
        costLine =
            "Cannot calculate the minimum monthly bill for this configuration. Consider running " +
                clc.bold("npm install -g firebase-tools");
    }
    else {
        const cost = pricing.monthlyMinInstanceCost(want).toFixed(2);
        costLine = `With these options, your minimum bill will be $${cost} in a 30-day month`;
    }
    let cudAnnotation = "";
    if (want.some((fn) => fn.platform == "gcfv2" && fn.minInstances)) {
        cudAnnotation =
            "\nThis bill can be lowered with a one year commitment. See https://cloud.google.com/run/cud for more";
    }
    const warnMessage = "The following functions have reserved minimum instances. This will " +
        "reduce the frequency of cold starts but increases the minimum cost. " +
        "You will be charged for the memory allocation and a fraction of the " +
        "CPU allocation of instances while they are idle.\n\n" +
        functionLines +
        "\n\n" +
        costLine +
        cudAnnotation;
    utils.logLabeledWarning("functions", warnMessage);
    const proceed = await prompt_1.promptOnce({
        type: "confirm",
        name: "confirm",
        default: false,
        message: "Would you like to proceed with deployment?",
    });
    if (!proceed) {
        throw new error_1.FirebaseError("Deployment canceled.", { exit: 1 });
    }
}
exports.promptForMinInstances = promptForMinInstances;
