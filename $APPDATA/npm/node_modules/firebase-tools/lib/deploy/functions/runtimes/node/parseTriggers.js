"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addResourcesToBackend = exports.discoverBackend = exports.useStrategy = void 0;
const path = require("path");
const _ = require("lodash");
const child_process_1 = require("child_process");
const error_1 = require("../../../../error");
const logger_1 = require("../../../../logger");
const backend = require("../../backend");
const api = require("../../../../api");
const proto = require("../../../../gcp/proto");
const TRIGGER_PARSER = path.resolve(__dirname, "./triggerParser.js");
function removeInspectOptions(options) {
    return options.filter((opt) => !opt.startsWith("--inspect"));
}
function parseTriggers(projectId, sourceDir, configValues, envs) {
    return new Promise((resolve, reject) => {
        const env = Object.assign({}, envs);
        env.GCLOUD_PROJECT = projectId;
        if (!_.isEmpty(configValues)) {
            env.CLOUD_RUNTIME_CONFIG = JSON.stringify(configValues);
        }
        const execArgv = removeInspectOptions(process.execArgv);
        if (env.NODE_OPTIONS) {
            env.NODE_OPTIONS = removeInspectOptions(env.NODE_OPTIONS.split(" ")).join(" ");
        }
        const parser = child_process_1.fork(TRIGGER_PARSER, [sourceDir], {
            silent: true,
            env: env,
            execArgv: execArgv,
        });
        parser.on("message", (message) => {
            if (message.triggers) {
                resolve(message.triggers);
            }
            else if (message.error) {
                reject(new error_1.FirebaseError(message.error, { exit: 1 }));
            }
        });
        parser.on("exit", (code) => {
            if (code !== 0) {
                reject(new error_1.FirebaseError("There was an unknown problem while trying to parse function triggers.", { exit: 2 }));
            }
        });
    });
}
function useStrategy(context) {
    return Promise.resolve(true);
}
exports.useStrategy = useStrategy;
async function discoverBackend(projectId, sourceDir, runtime, configValues, envs) {
    const triggerAnnotations = await parseTriggers(projectId, sourceDir, configValues, envs);
    const want = Object.assign(Object.assign({}, backend.empty()), { environmentVariables: envs });
    for (const annotation of triggerAnnotations) {
        addResourcesToBackend(projectId, runtime, annotation, want);
    }
    return want;
}
exports.discoverBackend = discoverBackend;
function addResourcesToBackend(projectId, runtime, annotation, want) {
    Object.freeze(annotation);
    for (const region of annotation.regions || [api.functionsDefaultRegion]) {
        let trigger;
        if (!!annotation.httpsTrigger == !!annotation.eventTrigger) {
            throw new error_1.FirebaseError("Unexpected annotation generated by the Firebase Functions SDK. This should never happen.");
        }
        if (annotation.httpsTrigger) {
            let allowInsecure;
            if ("allowInsecure" in annotation.httpsTrigger) {
                allowInsecure = !!annotation.httpsTrigger.allowInsecure;
            }
            else {
                allowInsecure = !annotation.platform || annotation.platform === "gcfv1";
            }
            trigger = { allowInsecure };
            if (annotation.failurePolicy) {
                logger_1.logger.warn(`Ignoring retry policy for HTTPS function ${annotation.name}`);
            }
            proto.copyIfPresent(trigger, annotation.httpsTrigger, "invoker", "invoker");
        }
        else {
            trigger = {
                eventType: annotation.eventTrigger.eventType,
                eventFilters: {
                    resource: annotation.eventTrigger.resource,
                },
                retry: !!annotation.failurePolicy,
            };
        }
        const cloudFunctionName = {
            id: annotation.name,
            region: region,
            project: projectId,
        };
        const cloudFunction = Object.assign(Object.assign({ platform: annotation.platform || "gcfv1" }, cloudFunctionName), { entryPoint: annotation.entryPoint, runtime: runtime, trigger: trigger });
        if (annotation.vpcConnector) {
            let maybeId = annotation.vpcConnector;
            if (!maybeId.includes("/")) {
                maybeId = `projects/${projectId}/locations/${region}/connectors/${maybeId}`;
            }
            cloudFunction.vpcConnector = maybeId;
        }
        proto.copyIfPresent(cloudFunction, annotation, "concurrency", "serviceAccountEmail", "labels", "vpcConnectorEgressSettings", "ingressSettings", "timeout", "maxInstances", "minInstances", "availableMemoryMb");
        if (annotation.schedule) {
            want.requiredAPIs["pubsub"] = "pubsub.googleapis.com";
            want.requiredAPIs["scheduler"] = "cloudscheduler.googleapis.com";
            const id = backend.scheduleIdForFunction(cloudFunctionName);
            const schedule = {
                id,
                project: projectId,
                schedule: annotation.schedule.schedule,
                transport: "pubsub",
                targetService: cloudFunctionName,
            };
            proto.copyIfPresent(schedule, annotation.schedule, "timeZone", "retryConfig");
            want.schedules.push(schedule);
            const topic = {
                id,
                project: projectId,
                labels: backend.SCHEDULED_FUNCTION_LABEL,
                targetService: cloudFunctionName,
            };
            want.topics.push(topic);
            if (backend.isEventTrigger(cloudFunction.trigger)) {
                cloudFunction.trigger.eventFilters.resource = `${cloudFunction.trigger.eventFilters.resource}/${id}`;
            }
            cloudFunction.labels = Object.assign(Object.assign({}, cloudFunction.labels), { "deployment-scheduled": "true" });
        }
        want.cloudFunctions.push(cloudFunction);
    }
}
exports.addResourcesToBackend = addResourcesToBackend;
