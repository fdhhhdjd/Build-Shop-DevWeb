"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerHelper = exports.deleteGcfArtifacts = exports.listGcfPaths = exports.ContainerRegistryCleaner = exports.cleanupBuildImages = exports.SUBDOMAIN_MAPPING = void 0;
const clc = require("cli-color");
const api_1 = require("../../api");
const logger_1 = require("../../logger");
const docker = require("../../gcp/docker");
const backend = require("./backend");
const utils = require("../../utils");
const error_1 = require("../../error");
exports.SUBDOMAIN_MAPPING = {
    "us-west2": "us",
    "us-west3": "us",
    "us-west4": "us",
    "us-central1": "us",
    "us-central2": "us",
    "us-east1": "us",
    "us-east4": "us",
    "northamerica-northeast1": "us",
    "southamerica-east1": "us",
    "europe-west1": "eu",
    "europe-west2": "eu",
    "europe-west3": "eu",
    "europe-west5": "eu",
    "europe-west6": "eu",
    "europe-central2": "eu",
    "asia-east1": "asia",
    "asia-east2": "asia",
    "asia-northeast1": "asia",
    "asia-northeast2": "asia",
    "asia-northeast3": "asia",
    "asia-south1": "asia",
    "asia-southeast2": "asia",
    "australia-southeast1": "asia",
};
async function retry(func) {
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    const MAX_RETRIES = 3;
    const INITIAL_BACKOFF = 100;
    let retry = 0;
    while (true) {
        try {
            return await func();
        }
        catch (error) {
            logger_1.logger.debug("Failed docker command with error", error);
            retry += 1;
            if (retry >= MAX_RETRIES) {
                throw new error_1.FirebaseError("Failed to clean up artifacts", { original: error });
            }
            await sleep(Math.pow(INITIAL_BACKOFF, retry - 1));
        }
    }
}
async function cleanupBuildImages(functions) {
    utils.logBullet(clc.bold.cyan("functions: ") + "cleaning up build files...");
    const gcrCleaner = new ContainerRegistryCleaner();
    const failedDomains = new Set();
    await Promise.all(functions.map((func) => (async () => {
        try {
            await gcrCleaner.cleanupFunction(func);
        }
        catch (err) {
            const path = `${func.project}/${exports.SUBDOMAIN_MAPPING[func.region]}/gcf`;
            failedDomains.add(`https://console.cloud.google.com/gcr/images/${path}`);
        }
    })()));
    if (failedDomains.size) {
        let message = "Unhandled error cleaning up build images. This could result in a small monthly bill if not corrected. ";
        message +=
            "You can attempt to delete these images by redeploying or you can delete them manually at";
        if (failedDomains.size == 1) {
            message += " " + failedDomains.values().next().value;
        }
        else {
            message += [...failedDomains].map((domain) => "\n\t" + domain).join("");
        }
        utils.logLabeledWarning("functions", message);
    }
}
exports.cleanupBuildImages = cleanupBuildImages;
class ContainerRegistryCleaner {
    constructor() {
        this.helpers = {};
    }
    helper(location) {
        const subdomain = exports.SUBDOMAIN_MAPPING[location] || "us";
        if (!this.helpers[subdomain]) {
            const origin = `https://${subdomain}.${api_1.containerRegistryDomain}`;
            this.helpers[subdomain] = new DockerHelper(origin);
        }
        return this.helpers[subdomain];
    }
    async cleanupFunction(func) {
        const helper = this.helper(func.region);
        const uuids = (await helper.ls(`${func.project}/gcf/${func.region}`)).children;
        const uuidTags = {};
        const loadUuidTags = [];
        for (const uuid of uuids) {
            loadUuidTags.push((async () => {
                const path = `${func.project}/gcf/${func.region}/${uuid}`;
                const tags = (await helper.ls(path)).tags;
                uuidTags[path] = tags;
            })());
        }
        await Promise.all(loadUuidTags);
        const extractFunction = /^(.*)_version-\d+$/;
        const entry = Object.entries(uuidTags).find(([, tags]) => {
            return tags.find((tag) => { var _a; return ((_a = extractFunction.exec(tag)) === null || _a === void 0 ? void 0 : _a[1]) === func.id; });
        });
        if (!entry) {
            logger_1.logger.debug("Could not find image for function", backend.functionName(func));
            return;
        }
        await helper.rm(entry[0]);
    }
}
exports.ContainerRegistryCleaner = ContainerRegistryCleaner;
function getHelper(cache, subdomain) {
    if (!cache[subdomain]) {
        cache[subdomain] = new DockerHelper(`https://${subdomain}.${api_1.containerRegistryDomain}`);
    }
    return cache[subdomain];
}
async function listGcfPaths(projectId, locations, dockerHelpers = {}) {
    if (!locations) {
        locations = Object.keys(exports.SUBDOMAIN_MAPPING);
    }
    const invalidRegion = locations.find((loc) => !exports.SUBDOMAIN_MAPPING[loc]);
    if (invalidRegion) {
        throw new error_1.FirebaseError(`Invalid region ${invalidRegion} supplied`);
    }
    const locationsSet = new Set(locations);
    const subdomains = new Set(Object.values(exports.SUBDOMAIN_MAPPING));
    const failedSubdomains = [];
    const listAll = [];
    for (const subdomain of subdomains) {
        listAll.push((async () => {
            try {
                return getHelper(dockerHelpers, subdomain).ls(`${projectId}/gcf`);
            }
            catch (err) {
                failedSubdomains.push(subdomain);
                logger_1.logger.debug(err);
                const stat = {
                    children: [],
                    digests: [],
                    tags: [],
                };
                return Promise.resolve(stat);
            }
        })());
    }
    const gcfDirs = (await Promise.all(listAll))
        .map((results) => results.children)
        .reduce((acc, val) => [...acc, ...val], [])
        .filter((loc) => locationsSet.has(loc));
    if (failedSubdomains.length == subdomains.size) {
        throw new error_1.FirebaseError("Failed to search all subdomains.");
    }
    else if (failedSubdomains.length > 0) {
        throw new error_1.FirebaseError(`Failed to search the following subdomains: ${failedSubdomains.join(",")}`);
    }
    return gcfDirs.map((loc) => {
        return `${exports.SUBDOMAIN_MAPPING[loc]}.${api_1.containerRegistryDomain}/${projectId}/gcf/${loc}`;
    });
}
exports.listGcfPaths = listGcfPaths;
async function deleteGcfArtifacts(projectId, locations, dockerHelpers = {}) {
    if (!locations) {
        locations = Object.keys(exports.SUBDOMAIN_MAPPING);
    }
    const invalidRegion = locations.find((loc) => !exports.SUBDOMAIN_MAPPING[loc]);
    if (invalidRegion) {
        throw new error_1.FirebaseError(`Invalid region ${invalidRegion} supplied`);
    }
    const subdomains = new Set(Object.values(exports.SUBDOMAIN_MAPPING));
    const failedSubdomains = [];
    const deleteLocations = locations.map((loc) => {
        try {
            return getHelper(dockerHelpers, exports.SUBDOMAIN_MAPPING[loc]).rm(`${projectId}/gcf/${loc}`);
        }
        catch (err) {
            failedSubdomains.push(exports.SUBDOMAIN_MAPPING[loc]);
            logger_1.logger.debug(err);
        }
    });
    await Promise.all(deleteLocations);
    if (failedSubdomains.length == subdomains.size) {
        throw new error_1.FirebaseError("Failed to search all subdomains.");
    }
    else if (failedSubdomains.length > 0) {
        throw new error_1.FirebaseError(`Failed to search the following subdomains: ${failedSubdomains.join(",")}`);
    }
}
exports.deleteGcfArtifacts = deleteGcfArtifacts;
class DockerHelper {
    constructor(origin) {
        this.cache = {};
        this.client = new docker.Client(origin);
    }
    async ls(path) {
        if (!this.cache[path]) {
            const raw = await retry(() => this.client.listTags(path));
            this.cache[path] = {
                tags: raw.tags,
                digests: Object.keys(raw.manifest),
                children: raw.child,
            };
        }
        return this.cache[path];
    }
    async rm(path) {
        let toThrowLater = undefined;
        const stat = await this.ls(path);
        const recursive = stat.children.map((child) => (async () => {
            try {
                await this.rm(`${path}/${child}`);
                stat.children.splice(stat.children.indexOf(child), 1);
            }
            catch (err) {
                toThrowLater = err;
            }
        })());
        const deleteTags = stat.tags.map((tag) => (async () => {
            try {
                await retry(() => this.client.deleteTag(path, tag));
                stat.tags.splice(stat.tags.indexOf(tag), 1);
            }
            catch (err) {
                logger_1.logger.debug("Got error trying to remove docker tag:", err);
                toThrowLater = err;
            }
        })());
        await Promise.all(deleteTags);
        const deleteImages = stat.digests.map((digest) => (async () => {
            try {
                await retry(() => this.client.deleteImage(path, digest));
                stat.digests.splice(stat.digests.indexOf(digest), 1);
            }
            catch (err) {
                logger_1.logger.debug("Got error trying to remove docker image:", err);
                toThrowLater = err;
            }
        })());
        await Promise.all(deleteImages);
        await Promise.all(recursive);
        if (toThrowLater) {
            throw toThrowLater;
        }
    }
}
exports.DockerHelper = DockerHelper;
