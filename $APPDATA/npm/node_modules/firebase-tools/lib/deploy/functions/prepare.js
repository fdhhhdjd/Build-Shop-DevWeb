"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepare = void 0;
const clc = require("cli-color");
const ensureCloudBuildEnabled_1 = require("./ensureCloudBuildEnabled");
const functionsDeployHelper_1 = require("./functionsDeployHelper");
const utils_1 = require("../../utils");
const prepareFunctionsUpload_1 = require("./prepareFunctionsUpload");
const prompts_1 = require("./prompts");
const backend = require("./backend");
const ensureApiEnabled = require("../../ensureApiEnabled");
const functionsConfig = require("../../functionsConfig");
const functionsEnv = require("../../functions/env");
const previews_1 = require("../../previews");
const projectUtils_1 = require("../../projectUtils");
const track_1 = require("../../track");
const runtimes = require("./runtimes");
const validate = require("./validate");
const utils = require("../../utils");
const logger_1 = require("../../logger");
function hasUserConfig(config) {
    return Object.keys(config).length > 1;
}
function hasDotenv(opts) {
    return previews_1.previews.dotenv && functionsEnv.hasUserEnvs(opts);
}
async function prepare(context, options, payload) {
    if (!options.config.src.functions) {
        return;
    }
    const runtimeDelegate = await runtimes.getRuntimeDelegate(context, options);
    logger_1.logger.debug(`Validating ${runtimeDelegate.name} source`);
    await runtimeDelegate.validate();
    logger_1.logger.debug(`Building ${runtimeDelegate.name} source`);
    await runtimeDelegate.build();
    const projectId = projectUtils_1.needProjectId(options);
    const checkAPIsEnabled = await Promise.all([
        ensureApiEnabled.ensure(projectId, "cloudfunctions.googleapis.com", "functions"),
        ensureApiEnabled.check(projectId, "runtimeconfig.googleapis.com", "runtimeconfig", true),
        ensureCloudBuildEnabled_1.ensureCloudBuildEnabled(projectId),
    ]);
    context.runtimeConfigEnabled = checkAPIsEnabled[1];
    const firebaseConfig = await functionsConfig.getFirebaseConfig(options);
    context.firebaseConfig = firebaseConfig;
    const runtimeConfig = await prepareFunctionsUpload_1.getFunctionsConfig(context);
    utils.assertDefined(options.config.src.functions.source, "Error: 'functions.source' is not defined");
    const source = options.config.src.functions.source;
    const firebaseEnvs = functionsEnv.loadFirebaseEnvs(firebaseConfig, projectId);
    const userEnvOpt = {
        functionsSource: options.config.path(source),
        projectId: projectId,
        projectAlias: options.projectAlias,
    };
    const userEnvs = functionsEnv.loadUserEnvs(userEnvOpt);
    const tag = hasUserConfig(runtimeConfig)
        ? hasDotenv(userEnvOpt)
            ? "mixed"
            : "runtime_config"
        : hasDotenv(userEnvOpt)
            ? "dotenv"
            : "none";
    track_1.track("functions_codebase_deploy_env_method", tag);
    logger_1.logger.debug(`Analyzing ${runtimeDelegate.name} backend spec`);
    const wantBackend = await runtimeDelegate.discoverSpec(runtimeConfig, firebaseEnvs);
    wantBackend.environmentVariables = Object.assign(Object.assign({}, userEnvs), firebaseEnvs);
    payload.functions = { backend: wantBackend };
    if (backend.isEmptyBackend(wantBackend)) {
        return;
    }
    if (wantBackend.cloudFunctions.find((f) => f.platform === "gcfv2")) {
        const V2_APIS = {
            artifactregistry: "artifactregistry.googleapis.com",
            cloudrun: "run.googleapis.com",
            eventarc: "eventarc.googleapis.com",
            pubsub: "pubsub.googleapis.com",
        };
        const enablements = Object.entries(V2_APIS).map(([tag, api]) => {
            return ensureApiEnabled.ensure(context.projectId, api, tag);
        });
        await Promise.all(enablements);
    }
    utils_1.logBullet(clc.cyan.bold("functions:") +
        " preparing " +
        clc.bold(options.config.src.functions.source) +
        " directory for uploading...");
    if (wantBackend.cloudFunctions.find((fn) => fn.platform === "gcfv1")) {
        context.functionsSourceV1 = await prepareFunctionsUpload_1.prepareFunctionsUpload(runtimeConfig, options);
    }
    if (wantBackend.cloudFunctions.find((fn) => fn.platform === "gcfv2")) {
        context.functionsSourceV2 = await prepareFunctionsUpload_1.prepareFunctionsUpload(undefined, options);
    }
    wantBackend.cloudFunctions.forEach((fn) => {
        fn.environmentVariables = wantBackend.environmentVariables;
    });
    await Promise.all(Object.keys(wantBackend.requiredAPIs).map((friendlyName) => {
        ensureApiEnabled.ensure(projectId, wantBackend.requiredAPIs[friendlyName], friendlyName, false);
    }));
    validate.functionIdsAreValid(wantBackend.cloudFunctions);
    context.filters = functionsDeployHelper_1.getFilterGroups(options);
    const wantFunctions = wantBackend.cloudFunctions.filter((fn) => {
        return functionsDeployHelper_1.functionMatchesAnyGroup(fn, context.filters);
    });
    const haveFunctions = (await backend.existingBackend(context)).cloudFunctions;
    await prompts_1.promptForFailurePolicies(options, wantFunctions, haveFunctions);
    await prompts_1.promptForMinInstances(options, wantFunctions, haveFunctions);
    await backend.checkAvailability(context, wantBackend);
}
exports.prepare = prepare;
